# 📘 **脚本工具箱：需求规格与详细设计书 V4**

## **第一部分：需求规格说明 (Business Requirements)**

### **1. 项目定位**

一个基于 Qt (C++) 的本地桌面容器，用于管理、配置和运行 Python / R 脚本以及任意可执行的命令行工具。
**核心价值**：通过 YAML 元数据驱动界面，利用 **uv** (Python) / **pak** (R) 以及可插拔的 Runner/Env 策略实现环境隔离与依赖管理，保证脚本或 CLI “拿来即用，永不冲突”。

### **2. 核心功能需求**

#### **R1. 工具扫描与解析**

* **扫描规则**：自动扫描指定目录（如 `tools/`），每个子目录为一个独立工具。
* **元数据解析**：解析 `tool.yaml`，提取名称、版本、标签、环境配置、参数定义。
* **异常处理**：若 YAML 格式错误或关键字段缺失，需在界面明确标记并提示。

#### **R2. 环境管理 (关键路径)**

* **依赖工具检测**：
  * Python 模式：必须检测系统是否安装 `uv`。
  * R 模式：必须检测系统是否安装 `pak`。
  * 通用 CLI 模式：检测 `runtime.entry` 指定的可执行文件是否可用（`which/where`），必要时允许在 YAML 中声明 `setup.command`（例如下载解压某个独立二进制）。
  * **缺失行为**：如果未安装，必须弹窗引导用户安装（提供命令或自动安装）。
* **虚拟环境隔离**：
  * 每个工具拥有独立的运行环境（`.venv`、`.r-lib`、自定义缓存目录）；无需隔离的 CLI 可以选择 `env.strategy=none`。
  * **自动构建**：根据 YAML 的 `dependencies` 列表，自动执行 `uv sync`、`pak install` 或自定义 `setup.command`。
  * **智能缓存**：依赖列表未变动时，跳过安装步骤直接运行。

#### **R3. 动态界面生成 (UI)**

* 根据 YAML 的 `params` 字段自动生成表单：
  * `file/dir` → 文件选择器
  * `select` → 下拉框
  * `int/float` → 数字输入框
  * `text` → 文本框
* 支持参数校验（必填项、类型检查）。

#### **R4. 运行与日志系统 (Process & I/O)**

* **独立运行目录**：每次运行必须创建 `runs/YYYY-MM-DD_ID/`。
* **全量留痕**：
  * `command.txt` (复现命令)
  * `metadata.json` (当前参数快照)
  * `stdout.log` / `stderr.log` (完整日志)
* **实时交互**：UI 需实时显示脚本输出，并支持“停止”按钮终止进程。
* **结果访问**：运行结束后，UI 提供按钮直接打开输出文件或目录。

#### **R5. 全局配置**

* 设置工作区路径（Tools root, Runs root）。
* 设置并发任务数限制。
* 设置 Python / R 解释器路径以及自定义 CLI（如 Node、Java、ffmpeg）的查找策略（PATH 优先、手工指定等）。

---

## **第二部分：系统架构设计 (System Architecture)**

为了满足上述需求并确保界面流畅，采用 **UI/Logic 物理隔离** + **Coordinator-Worker 线程模型**。

### **1. 总体架构图**

```text
[ UI 层 (Main Thread) ]          [ Core 层 (Controller/Coordinator) ]       [ Worker 层 (Background Threads) ]
       |                                       |                                         |
   MainWindow  <----(Signals/DTO)---->   CoreService   -----(调度/创建)---->    ScanWorker (IO密集)
       |                                       |                                         |
   DynamicForm                                 |------------------------------->    EnvWorker (阻塞/安装)
       |                                       |                                         |
   LogConsole                                  |------------------------------->    JobWorker (运行/日志)
```

### **2. 模块划分与职责**

#### **2.1 UI 层 (`src/ui`)**

* **职责**：只负责显示数据和接收用户输入。不含任何业务逻辑。
* **交互方式**：将用户填写的表单打包成 `RunRequestDTO` 发送给 Core。

#### **2.2 Core 调度层 (`src/core/CoreService`)**

* **职责**：业务逻辑的总入口（Facade）。
* **功能**：
  * 接收 UI 请求（扫描、运行、停止）。
  * **状态管理**：维护当前哪些任务在运行，环境是否就绪。
  * **线程调度**：创建 Worker 并将其移入 (`moveToThread`) 后台线程。

#### **2.3 Worker 执行层 (`src/core/workers`)**

* **ScanWorker**：递归遍历目录，解析 YAML，返回 `QList<ToolDTO>`。
* **EnvWorker**：
  * 执行 `QProcess::execute("uv", ...)`。
  * 这是**最耗时**的一步，必须在后台线程，否则界面会假死。
* **JobWorker**：
  * 管理脚本生命周期。
  * 处理 `QProcess` 的 `readyRead` 信号，写入日志文件。

#### **2.4 公共数据层 (`src/common`)**

* 定义所有 DTO (Data Transfer Object)，如 `ToolDTO`, `ParamDTO`。
* UI 和 Core 均依赖此层，但互不依赖。

---

## **第三部分：详细设计与流程 (Detailed Design)**

### **1. 数据结构定义 (DTO)**

```cpp
// 运行时配置
struct RuntimeConfig {
    QString type;          // "python", "r", "generic"
    QString entry;         // 脚本路径或可执行文件
    QStringList args;      // 默认参数模板
    bool shellWrap;        // 是否需要 shell 包裹执行
    QString workdir;       // 相对工具根目录
    QMap<QString, QString> extraEnv;
    int timeoutSeconds;    // 0 表示不限
};

// 环境配置
struct EnvironmentConfig {
    QString strategy;         // "uv", "pak", "none", "custom"
    QString interpreterPath;  // Python/R/其他解释器的显式路径
    QStringList dependencies; // 依赖列表
    QString cacheKey;         // 指纹缓存（.env_hash）
};

// 工具元数据
struct ToolDTO {
    QString id;
    QString name;
    QString description;
    RuntimeConfig runtime;
    EnvironmentConfig environment;
    // 参数定义
    QList<ParamDTO> params;
};

// 运行请求
struct RunRequestDTO {
    QString toolId;
    QMap<QString, QVariant> inputs; // key: value
};
```

`RuntimeConfig.args` 采用模板语法（`{{params.foo}}`, `{{runtime.workdir}}`, `{{output.dir}}`）在 JobWorker 中展开，避免字符串拼接带来的转义风险。`RuntimeConfig.shellWrap` 仅在需要通过 `cmd /c`、`/bin/sh -c` 调用复合命令时启用；默认情况下使用 `QProcess::setProgram()` + `setArguments()` 直接传参。`EnvironmentConfig.strategy` 决定 EnvWorker 采用的安装/校验逻辑：

* `uv`: 针对 Python，负责 `.venv` 管理与 `uv pip install`。
* `pak`: 针对 R，负责 `.r-lib` 目录及 `pak::pkg_install`。
* `none`: 直接使用系统可执行文件，不创建隔离目录，通常用于现成 CLI（如 `ffmpeg`、`imagemagick`、`dotnet`）。
* `custom`: 钩子式策略，支持未来扩展（如 Node.js、Java、Docker），在 YAML 中通过 `env.customScript` 或 `setup.command` 描述初始化步骤。

通过将环境与运行配置拆分，UI/Core 可以以统一 DTO 处理“Python/R/任意 CLI”三种模式，RunnerFactory 只需根据 `runtime.type` 选择 `PythonRunner`、`RRunner`、`GenericRunner` 等策略类即可。

### **2. 核心业务流程**

#### **流程 A：环境准备与自愈 (EnvWorker 逻辑)**

这是实现 R2 需求的关键。

1. **Strategy Selection**：根据 `EnvironmentConfig.strategy` 交由 `EnvStrategyFactory` 生成对应的 `IEnvStrategy` 实例（`UvStrategy`、`PakStrategy`、`NoopStrategy`、`CustomCommandStrategy`）。该实例拥有统一的 `check()` / `install()` / `teardown()` 接口。
2. **Check Phase**：
    * 读取 `env` 块（依赖、解释器、额外钩子）并计算 Hash。
    * 对比 `.env_hash` 文件或策略自带缓存（如容器镜像 digest）。
    * **若一致** -> 直接触发 `envReady`。
3. **Install Phase (当 Hash 不一致或策略要求强制刷新)**：
    * `UvStrategy`：`uv venv .venv` → `uv pip install dep1 dep2 ...`。
    * `PakStrategy`：`Rscript -e "pak::pkg_install(c('dep1', ...))"`，将库落地到 `.r-lib/`。
    * `NoopStrategy`（generic CLI）：跳过安装，但执行 `probe()` 检查命令可用性（例如通过 `where ffmpeg`），并在失败时回调 UI。
    * `CustomCommandStrategy`：执行 YAML 中定义的 `setup.command`（shell 脚本、PowerShell、make 等），允许拉取 Docker/Node/Java 依赖。
    * 成功后写入新的 Hash → `envReady`；失败则包装错误信息触发 `envError`。

#### **流程 B：脚本执行与日志 (JobWorker 逻辑)**

这是实现 R4 需求的关键。

1. **Init**: 接收 `RunRequestDTO` 和 `EnvPath`。
2. **FileSystem**:
    * 创建 `runs/2023-11-28_ToolID/`。
    * 打开 `stdout.log` 和 `stderr.log` 的 `QFile` 句柄。
3. **Command Builder**：
    * `RunnerFactory` 根据 `runtime.type` 选择 `PythonRunner`、`RRunner` 或 `GenericRunner`。
    * Runner 负责将模板化参数（`{{params.rows}}`、`{{run.outputs}}` 等）展开为 `Executable + QStringList args`。
    * **PythonRunner**：`.venv/Scripts/python.exe entry.py --arg1 val1`。
    * **RRunner**：`Rscript entry.R --arg1 val1` 并注入 `.libPaths()`。
    * **GenericRunner**：尊重 YAML 中的 `runtime.entry` + `args` + `shell` 配置，可表示 `ffmpeg -i {{file}} -vf ...`、`dotnet tool.dll` 等任意 CLI。
    * 所有 Runner 均以 `QProcess::setArguments()` 注入参数，禁止直接拼接字符串，必要时才设置 `shellWrap`。
4. **Execution**:
    * `QProcess::start()`
    * 连接 `readyReadStandardOutput` -> 写入 log 文件 -> `emit logReceived(text)`。
5. **Finish**:
    * 关闭文件句柄。
    * `emit jobFinished(exitCode)`。

### **3. 目录结构规范**

```text
ProjectRoot/
├── tools/                  # [输入] 工具库
│   ├── data_processor/
│   │   ├── tool.yaml
│   │   ├── script.py
│   │   ├── .venv/        # [自动生成] uv 环境
│   │   └── .env_hash     # [自动生成] 依赖指纹
├── runs/                   # [输出] 运行记录
│   ├── 2025-11-28_10-00_data_processor/
│   │   ├── command.txt
│   │   ├── metadata.json
│   │   ├── logs/
│   │   │   ├── stdout.log
│   │   │   └── stderr.log
│   │   └── outputs/        # 脚本生成的文件
```

### **4. tool.yaml 规范**

```yaml
name: "数据清洗工具"
version: "2.0"

runtime:
  type: python                # python / r / generic
  entry: "scripts/clean.py"   # Python/R => 脚本路径；generic => 可执行
  args:
    - "--source"
    - "{{params.source}}"
    - "--rows"
    - "{{params.rows}}"
  shell: false
  workdir: "."
  extra_env:
    TABLE_FORMAT: "csv"
  timeout: 3600

env:
  strategy: uv
  interpreter: ""
  dependencies:
    - pandas>=2.0
    - numpy

params:
  - key: "source"
    label: "源文件"
    type: file
    required: true
  - key: "rows"
    label: "读取行数"
    type: int
    default: 100
```

### **5. 约定与最佳实践补充**

#### 5.1 `tool.yaml` 完整字段

```yaml
id: "data_processor"        # 目录名为默认 id，允许显式覆盖；必须唯一
name: "数据清洗工具"          # UI 展示名
version: "2.0"              # 仅展示，不参与比较
description: "简单描述"       # UI tooltip
tags: ["data", "clean"]     # 过滤用
category: "数据处理"         # UI 侧边栏分类

runtime:
  type: python | r | generic   # 决定 Runner 策略
  entry: "scripts/run.py"      # Python/R=脚本，相对工具目录；generic=可执行或命令
  args: []                     # 运行时默认参数模板；可使用 {{params.xxx}}
  shell: false                 # 复杂命令需要 shell 时设为 true
  workdir: "."                 # 相对工具目录，默认 "."
  extra_env:                   # 运行时附加环境变量
    KEY: "VALUE"
  timeout: 0                   # 秒；0 表示无限
  thumbnail: "cover.png"       # 工具封面/卡片占位图
  expected_outputs:            # UI 可用来渲染“打开输出”按钮
    - path: "outputs/report.pdf"
      label: "报表 PDF"
      type: file | dir

params:                     # 数组，key 唯一
  - key: "source"
    label: "源文件"
    type: file | dir | select | int | float | text | bool
    required: true
    default: ""
    options: []             # select 专用；支持 {label, value}
    multi: false            # file/dir/select 多选
    min: 0                  # 数值型
    max: 1000000
    step: 1
    placeholder: ""
    pattern: ""             # text 正则校验
    description: ""         # UI 辅助文本

env:
  strategy: uv | pak | none | custom
  interpreter: ""            # 可选，空则用系统默认
  dependencies: []           # 字符串数组；空则视为无需安装
  cache_dir: ".venv"         # 若策略需要（Python/R），默认为 `.venv` / `.r-lib`
  setup:                     # custom/none 均可使用的预处理命令
    command: ""              # 如 `bash setup.sh`、`powershell -File init.ps1`
    shell: false
    workdir: "."
```

#### 5.2 环境与缓存策略

* 依赖指纹：对 `runtime.type`、`env.strategy`、`env.interpreter`、`env.dependencies`、`env.setup.command` 做稳定序列化（换行 `\n`，小写包名，排序），写入 `.env_hash`。若哈希不同则重建。
* 环境位置：`env.cache_dir` 默认为 `.venv`（Python）或 `.r-lib`（R）；`strategy=none` 仅记录 `.env_hash` 而不创建目录；`custom` 可以自定义缓存目录（如 `.node_modules_tool`）。
* 安装流程（Python）：`uv venv .venv` → `uv pip install -r`/列表。失败直接提示重试；若 `uv` 缺失，弹窗给出安装命令（用户可手动运行），允许“一键重装”。
* 安装流程（R）：`Rscript -e "pak::pkg_install(...)"`，R 库目录 `.r-lib`；同样以哈希触发重装。
* 安装流程（Generic/Custom）：若声明 `env.setup.command` 则在隔离目录或工具目录执行；否则默认仅做 `probe()`（`which/where`），必要时提示用户手动安装依赖。
* 并发：同一工具的 EnvWorker 加互斥，避免同时写入环境；不同工具可并行。
* 清理：提供“重置环境”操作：删除 `.venv/.r-lib/.env_hash` 后重新安装。

#### 5.3 运行与留痕细则

* 运行目录命名：`runs/YYYY-MM-DD_HH-MM-SS_{toolId}_{seq}`；若撞名递增 `seq`。
* 工作目录：`workdir` 基于工具目录；`QProcess` 的 `setWorkingDirectory` 指向运行目录，并在命令前写入 `command.txt`。
* 命令构建：参数值统一经过转义；布尔参数用 `--flag` 或 `--flag=false`。
* 元数据：`metadata.json` 存 `{ toolId, version, command, params, startedAt, envPath }`。
* 输出路径：约定为运行目录内的 `outputs/`；在启动前创建并通过 env 变量 `TOOL_OUTPUT_DIR` 传给脚本。
* 日志：标准输出/错误分别写入 `logs/stdout.log`、`logs/stderr.log`，UI 流式展示；超长行分块写入，最大文件尺寸（默认 50MB）后截断并提示。

#### 5.4 任务控制与并发

* 并发限制：CoreService 维护队列；超出并发数则排队，UI 展示状态。
* 停止语义：先发送 `terminate`（Python：`QProcess::terminate`；R 同），5 秒未退出则 `kill`；对子进程使用平台默认进程树终止（Windows 需 `taskkill /T`）。
* 状态机：`Pending → EnvPreparing → Ready → Running → Finished/Failed/Cancelled`；UI 根据信号更新。
* 热更新：扫描完成后缓存工具列表，支持“刷新”按钮重新扫描；若 YAML 变更，重新解析并刷新 UI。

#### 5.5 配置持久化

* 配置文件：`config.json` 位于应用数据目录（Win `%APPDATA%/toolbox/`，macOS `~/Library/Application Support/toolbox/`，Linux `~/.config/toolbox/`）。
* 内容：`toolsRoot`、`runsRoot`、`pythonPath`、`rPath`、`concurrency`、`proxy/extraEnv`。加载失败使用默认并提示。

#### 5.6 错误分级与提示

* YAML 解析：缺失关键字段→致命，标红并禁用运行；非关键字段缺失→警告，使用默认值并展示。
* 运行错误：进程退出码非 0 → 标记失败，提示查看 `stderr.log`。
* 环境错误：安装/检测失败 → 弹窗显示命令与输出，提供“重试”“跳过安装直接运行”选项。

#### 5.7 安全与资源

* 参数转义与路径规范，禁止将用户输入直接拼接 shell。
* 日志/运行目录清理策略：提供“清理”入口，默认保留最近 N 天（可配置）。
* 磁盘监控：运行前检查剩余空间不足时警告。

#### 5.8 跨平台补充

* 可执行路径：Python `.venv/bin/python`（Unix） / `.venv/Scripts/python.exe`（Windows）；Rscript 通过配置或 PATH 查找。
* 路径分隔与编码：内部统一使用 Qt 的 `QDir/QFileInfo`，序列化用 `/` 分隔。
* 代理/镜像：支持在配置中写入 `UV_INDEX_URL` 或 R `options(repos=...)`。

#### 5.9 通用 CLI Runner 最佳实践

* **模板化命令**：优先使用 `runtime.entry` + `runtime.args` 定义命令，不在字符串中拼接空格；参数模板可引用 `{{params.key}}`、`{{run.outputs}}` 等占位符，由 Runner 统一转义。
* **显式依赖探测**：所有 `runtime.type=generic` 的工具必须声明 `env.strategy`（通常为 `none` 或 `custom`）并提供 `setup.command` 或 `probe.command`，以在运行前校验二进制是否存在，缺失时为用户给出修复指引。
* **超时与资源限制**：合理填写 `runtime.timeout` 与 `env.cache_dir`，防止“长命令 + 残留文件夹”拖垮系统；计划支持在 YAML 中附带 `limits.cpu`、`limits.memory` 便于未来扩展。
* **输出契约**：通过 `runtime.expected_outputs` 或脚本日志约定结果文件放置路径，JobWorker 可在运行结束后检测存在性并暴露到 UI；同时强制脚本写入 `TOOL_OUTPUT_DIR`。
* **Shell 包裹最小化**：只有在 CLI 本身需要复合命令（如 `cmd /c "tool && other"`）时才打开 `shell:true`，以降低跨平台差异；否则 `QProcess` 直接注入参数即可避免转义问题。
* **配置复用**：通用 CLI 通常需要外部工具（Node/Java/Dotnet），推荐在全局设置中维护 `extras.paths` 映射（如 `{"node":"C:/Program Files/nodejs/node.exe"}`），并允许 YAML 使用 `{{config.bin.node}}` 占位符，保证不同机器一致。

### **6. 示例工具库 (Demo Tools Library)**

| 目录 | 语言 | 输出形态 | 依赖 | 说明 |
| --- | --- | --- | --- | --- |
| `tools/python_table_demo` | Python | 表格（CSV + 控制台预览） | `pandas` | 通过 `generate_table.py` 硬编码合成季度 KPI 表，支持调整行数/标题，便于验证 `params:int/text` 的渲染与传参。 |
| `tools/python_plot_demo` | Python | 图片（PNG） | `matplotlib`, `numpy` | `generate_plot.py` 使用 Matplotlib 绘制双折线并落盘，测试 `TOOL_OUTPUT_DIR`、图片预览及日志提示。 |
| `tools/r_table_demo` | R | 表格（CSV + 控台） | `tibble`, `dplyr` | `generate_table.R` 借助 `Select` 参数（focus region）高亮指定区域，演示 `select`/`int` 参数与 pak 依赖安装。 |
| `tools/r_plot_demo` | R | 图片（PNG） | `ggplot2` | `generate_plot.R` 用 ggplot2 绘制带置信带的能耗趋势折线，展示 R 工具的图片输出链路。 |

> 以上示例均位于 `tools/`，无外部数据依赖，默认写入 `outputs/`（若 UI 尚未注入 `TOOL_OUTPUT_DIR`，脚本会自行创建），便于开发阶段快速验证扫描、表单、运行与打包流程。

---

## **第四部分：开发路线图**

根据此设计，代码实现将分为以下阶段：

1. **基础架构 (Phase 1)**:
    * 建立 CMake 项目。
    * 实现 `src/common` (DTOs)。
    * 实现 `CoreService` 基本骨架和线程调度测试。
2. **核心业务 (Phase 2 - Worker)**:
    * 实现 `ScanWorker` (YAML 解析)。
    * 实现 `JobWorker` (QProcess + 日志文件)。
    * *暂时跳过环境安装，先用本机环境跑通。*
3. **UI 实现 (Phase 3)**:
    * `MainWindow` 布局。
    * **DynamicForm** 组件：将 DTO 映射为 Widget。
4. **环境增强 (Phase 4 - EnvWorker)**:
    * 接入 `uv` 和 `pak` 的检测与自动安装逻辑。
    * 完善错误提示弹窗。
