# 📘 **脚本工具箱：需求规格与详细设计书 V4**

## **第一部分：需求规格说明 (Business Requirements)**

### **1. 项目定位**

一个基于 Qt (C++) 的本地桌面容器，用于管理、配置和运行 Python / R 脚本。
**核心价值**：通过 YAML 元数据驱动界面，利用 **uv** (Python) 和 **pak** (R) 实现严格的环境隔离与依赖管理，保证脚本“拿来即用，永不冲突”。

### **2. 核心功能需求**

#### **R1. 工具扫描与解析**

* **扫描规则**：自动扫描指定目录（如 `tools/`），每个子目录为一个独立工具。
* **元数据解析**：解析 `tool.yaml`，提取名称、版本、标签、环境配置、参数定义。
* **异常处理**：若 YAML 格式错误或关键字段缺失，需在界面明确标记并提示。

#### **R2. 环境管理 (关键路径)**

* **依赖工具检测**：
  * Python 模式：必须检测系统是否安装 `uv`。
  * R 模式：必须检测系统是否安装 `pak`。
  * **缺失行为**：如果未安装，必须弹窗引导用户安装（提供命令或自动安装）。
* **虚拟环境隔离**：
  * 每个工具拥有独立的运行环境（`.venv` 或 R library）。
  * **自动构建**：根据 YAML 的 `dependencies` 列表，自动执行 `uv sync` 或 `pak install`。
  * **智能缓存**：依赖列表未变动时，跳过安装步骤直接运行。

#### **R3. 动态界面生成 (UI)**

* 根据 YAML 的 `params` 字段自动生成表单：
  * `file/dir` → 文件选择器
  * `select` → 下拉框
  * `int/float` → 数字输入框
  * `text` → 文本框
* 支持参数校验（必填项、类型检查）。

#### **R4. 运行与日志系统 (Process & I/O)**

* **独立运行目录**：每次运行必须创建 `runs/YYYY-MM-DD_ID/`。
* **全量留痕**：
  * `command.txt` (复现命令)
  * `metadata.json` (当前参数快照)
  * `stdout.log` / `stderr.log` (完整日志)
* **实时交互**：UI 需实时显示脚本输出，并支持“停止”按钮终止进程。
* **结果访问**：运行结束后，UI 提供按钮直接打开输出文件或目录。

#### **R5. 全局配置**

* 设置工作区路径（Tools root, Runs root）。
* 设置并发任务数限制。
* 设置 Python/R 解释器路径。

---

## **第二部分：系统架构设计 (System Architecture)**

为了满足上述需求并确保界面流畅，采用 **UI/Logic 物理隔离** + **Coordinator-Worker 线程模型**。

### **1. 总体架构图**

```text
[ UI 层 (Main Thread) ]          [ Core 层 (Controller/Coordinator) ]       [ Worker 层 (Background Threads) ]
       |                                       |                                         |
   MainWindow  <----(Signals/DTO)---->   CoreService   -----(调度/创建)---->    ScanWorker (IO密集)
       |                                       |                                         |
   DynamicForm                                 |------------------------------->    EnvWorker (阻塞/安装)
       |                                       |                                         |
   LogConsole                                  |------------------------------->    JobWorker (运行/日志)
```

### **2. 模块划分与职责**

#### **2.1 UI 层 (`src/ui`)**

* **职责**：只负责显示数据和接收用户输入。不含任何业务逻辑。
* **交互方式**：将用户填写的表单打包成 `RunRequestDTO` 发送给 Core。

#### **2.2 Core 调度层 (`src/core/CoreService`)**

* **职责**：业务逻辑的总入口（Facade）。
* **功能**：
  * 接收 UI 请求（扫描、运行、停止）。
  * **状态管理**：维护当前哪些任务在运行，环境是否就绪。
  * **线程调度**：创建 Worker 并将其移入 (`moveToThread`) 后台线程。

#### **2.3 Worker 执行层 (`src/core/workers`)**

* **ScanWorker**：递归遍历目录，解析 YAML，返回 `QList<ToolDTO>`。
* **EnvWorker**：
  * 执行 `QProcess::execute("uv", ...)`。
  * 这是**最耗时**的一步，必须在后台线程，否则界面会假死。
* **JobWorker**：
  * 管理脚本生命周期。
  * 处理 `QProcess` 的 `readyRead` 信号，写入日志文件。

#### **2.4 公共数据层 (`src/common`)**

* 定义所有 DTO (Data Transfer Object)，如 `ToolDTO`, `ParamDTO`。
* UI 和 Core 均依赖此层，但互不依赖。

---

## **第三部分：详细设计与流程 (Detailed Design)**

### **1. 数据结构定义 (DTO)**

```cpp
// 工具元数据
struct ToolDTO {
    QString id;
    QString name;
    QString command;
    // 环境配置
    QString envType; // "python" or "r"
    bool useUv;
    QStringList dependencies; 
    // 参数定义
    QList<ParamDTO> params;
};

// 运行请求
struct RunRequestDTO {
    QString toolId;
    QMap<QString, QVariant> inputs; // key: value
};
```

### **2. 核心业务流程**

#### **流程 A：环境准备与自愈 (EnvWorker 逻辑)**

这是实现 R2 需求的关键。

1. **Check Phase**:
    * 读取 `tool.yaml` 的依赖列表。
    * 计算依赖列表的 Hash 值。
    * 对比本地 `.env_hash` 文件。
    * **若一致** -> 发送 `envReady` 信号（秒级完成）。
2. **Install Phase (若不一致)**:
    * 发送信号 `statusChanged("正在构建虚拟环境...")`。
    * **Python (uv)**:
        * `uv venv .venv`
        * `uv pip install dep1 dep2 ...`
    * **R (pak)**:
        * `Rscript -e "pak::pkg_install(c('dep1', ...))"`
    * 成功 -> 写入新的 Hash -> 发送 `envReady`。
    * 失败 -> 发送 `envError`。

#### **流程 B：脚本执行与日志 (JobWorker 逻辑)**

这是实现 R4 需求的关键。

1. **Init**: 接收 `RunRequestDTO` 和 `EnvPath`。
2. **FileSystem**:
    * 创建 `runs/2023-11-28_ToolID/`。
    * 打开 `stdout.log` 和 `stderr.log` 的 `QFile` 句柄。
3. **Command Builder**:
    * Python: `.venv/bin/python script.py --arg1 val1`
    * R: `Rscript script.R --arg1 val1`
4. **Execution**:
    * `QProcess::start()`
    * 连接 `readyReadStandardOutput` -> 写入 log 文件 -> `emit logReceived(text)`。
5. **Finish**:
    * 关闭文件句柄。
    * `emit jobFinished(exitCode)`。

### **3. 目录结构规范**

```text
ProjectRoot/
├── tools/                  # [输入] 工具库
│   ├── data_processor/
│   │   ├── tool.yaml
│   │   ├── script.py
│   │   ├── .venv/        # [自动生成] uv 环境
│   │   └── .env_hash     # [自动生成] 依赖指纹
├── runs/                   # [输出] 运行记录
│   ├── 2025-11-28_10-00_data_processor/
│   │   ├── command.txt
│   │   ├── metadata.json
│   │   ├── logs/
│   │   │   ├── stdout.log
│   │   │   └── stderr.log
│   │   └── outputs/        # 脚本生成的文件
```

### **4. tool.yaml 规范**

```yaml
name: "数据清洗工具"
version: "2.0"

env:
  type: python
  use_uv: true
  dependencies:
    - pandas>=2.0
    - numpy

command: "clean.py"

params:
  - key: "source"
    label: "源文件"
    type: file
    required: true
  - key: "rows"
    label: "读取行数"
    type: int
    default: 100
```

### **5. 约定与最佳实践补充**

#### 5.1 `tool.yaml` 完整字段

```yaml
id: "data_processor"        # 目录名为默认 id，允许显式覆盖；必须唯一
name: "数据清洗工具"          # UI 展示名
version: "2.0"              # 仅展示，不参与比较
description: "简单描述"       # UI tooltip
tags: ["data", "clean"]     # 过滤用

env:
  type: python | r          # 必填
  use_uv: true              # R 无视该字段
  interpreter: ""           # 可选，空则用系统默认
  dependencies: []          # 字符串数组；空则视为无需安装

command: "clean.py"         # 可带相对路径/参数，如 "bin/run.sh --fast"
workdir: "."                # 相对工具目录，默认 "."
env_vars:                   # 运行时附加环境变量
  KEY: "VALUE"

params:                     # 数组，key 唯一
  - key: "source"
    label: "源文件"
    type: file | dir | select | int | float | text | bool
    required: true
    default: ""
    options: []             # select 专用；支持 {label, value}
    multi: false            # file/dir/select 多选
    min: 0                  # 数值型
    max: 1000000
    step: 1
    placeholder: ""
    pattern: ""             # text 正则校验
    description: ""         # UI 辅助文本
```

#### 5.2 环境与缓存策略

* 依赖指纹：对 `env.type/use_uv/interpreter/dependencies` 做稳定序列化（换行 `\n`，小写包名，排序），写入 `.env_hash`。若哈希不同则重建。
* 环境位置：默认在工具目录下 `.venv/`（Python）或 `.r-lib/`（R）。跨平台路径差异仅在可执行文件名，逻辑一致。
* 安装流程（Python）：`uv venv .venv` → `uv pip install -r`/列表。失败直接提示重试；若 `uv` 缺失，弹窗给出安装命令（用户可手动运行），允许“一键重装”。
* 安装流程（R）：`Rscript -e "pak::pkg_install(...)"`，R 库目录 `.r-lib`；同样以哈希触发重装。
* 并发：同一工具的 EnvWorker 加互斥，避免同时写入环境；不同工具可并行。
* 清理：提供“重置环境”操作：删除 `.venv/.r-lib/.env_hash` 后重新安装。

#### 5.3 运行与留痕细则

* 运行目录命名：`runs/YYYY-MM-DD_HH-MM-SS_{toolId}_{seq}`；若撞名递增 `seq`。
* 工作目录：`workdir` 基于工具目录；`QProcess` 的 `setWorkingDirectory` 指向运行目录，并在命令前写入 `command.txt`。
* 命令构建：参数值统一经过转义；布尔参数用 `--flag` 或 `--flag=false`。
* 元数据：`metadata.json` 存 `{ toolId, version, command, params, startedAt, envPath }`。
* 输出路径：约定为运行目录内的 `outputs/`；在启动前创建并通过 env 变量 `TOOL_OUTPUT_DIR` 传给脚本。
* 日志：标准输出/错误分别写入 `logs/stdout.log`、`logs/stderr.log`，UI 流式展示；超长行分块写入，最大文件尺寸（默认 50MB）后截断并提示。

#### 5.4 任务控制与并发

* 并发限制：CoreService 维护队列；超出并发数则排队，UI 展示状态。
* 停止语义：先发送 `terminate`（Python：`QProcess::terminate`；R 同），5 秒未退出则 `kill`；对子进程使用平台默认进程树终止（Windows 需 `taskkill /T`）。
* 状态机：`Pending → EnvPreparing → Ready → Running → Finished/Failed/Cancelled`；UI 根据信号更新。
* 热更新：扫描完成后缓存工具列表，支持“刷新”按钮重新扫描；若 YAML 变更，重新解析并刷新 UI。

#### 5.5 配置持久化

* 配置文件：`config.json` 位于应用数据目录（Win `%APPDATA%/toolbox/`，macOS `~/Library/Application Support/toolbox/`，Linux `~/.config/toolbox/`）。
* 内容：`toolsRoot`、`runsRoot`、`pythonPath`、`rPath`、`concurrency`、`proxy/extraEnv`。加载失败使用默认并提示。

#### 5.6 错误分级与提示

* YAML 解析：缺失关键字段→致命，标红并禁用运行；非关键字段缺失→警告，使用默认值并展示。
* 运行错误：进程退出码非 0 → 标记失败，提示查看 `stderr.log`。
* 环境错误：安装/检测失败 → 弹窗显示命令与输出，提供“重试”“跳过安装直接运行”选项。

#### 5.7 安全与资源

* 参数转义与路径规范，禁止将用户输入直接拼接 shell。
* 日志/运行目录清理策略：提供“清理”入口，默认保留最近 N 天（可配置）。
* 磁盘监控：运行前检查剩余空间不足时警告。

#### 5.8 跨平台补充

* 可执行路径：Python `.venv/bin/python`（Unix） / `.venv/Scripts/python.exe`（Windows）；Rscript 通过配置或 PATH 查找。
* 路径分隔与编码：内部统一使用 Qt 的 `QDir/QFileInfo`，序列化用 `/` 分隔。
* 代理/镜像：支持在配置中写入 `UV_INDEX_URL` 或 R `options(repos=...)`。

---

## **第四部分：开发路线图**

根据此设计，代码实现将分为以下阶段：

1. **基础架构 (Phase 1)**:
    * 建立 CMake 项目。
    * 实现 `src/common` (DTOs)。
    * 实现 `CoreService` 基本骨架和线程调度测试。
2. **核心业务 (Phase 2 - Worker)**:
    * 实现 `ScanWorker` (YAML 解析)。
    * 实现 `JobWorker` (QProcess + 日志文件)。
    * *暂时跳过环境安装，先用本机环境跑通。*
3. **UI 实现 (Phase 3)**:
    * `MainWindow` 布局。
    * **DynamicForm** 组件：将 DTO 映射为 Widget。
4. **环境增强 (Phase 4 - EnvWorker)**:
    * 接入 `uv` 和 `pak` 的检测与自动安装逻辑。
    * 完善错误提示弹窗。
